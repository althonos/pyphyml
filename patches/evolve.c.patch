diff --git a/src/evolve.c b/src/evolve.c
index 77be1d4..01b935a 100644
--- a/src/evolve.c
+++ b/src/evolve.c
@@ -36,7 +36,8 @@ int EVOLVE_Main(int argc, char **argv)
   }
 
   r_seed = (io->r_seed < 0) ? (time(NULL)) : (io->r_seed);
-  srand(r_seed);
+  // srand(r_seed);
+  MTRand_Seed(&io->rand, r_seed);
   io->r_seed = r_seed;
 
   io->data = Make_Empty_Alignment(io);
@@ -65,7 +66,7 @@ int EVOLVE_Main(int argc, char **argv)
   tree->times->scaled_pop_size = 1.E+3;
   tree->times->neff_growth     = 0.5;
 
-  EVOLVE_Coalescent(tree);
+  EVOLVE_Coalescent(&io->rand,tree);
 
   Init_Model(tree->data, tree->mod, io);
   Set_Model_Parameters(tree->mod);
@@ -77,7 +78,7 @@ int EVOLVE_Main(int argc, char **argv)
 
   sprintf(dum, "%s%d%s", "./", io->r_seed, "_evolve_stats.txt");
   fp = Openfile(dum, WRITE);
-  EVOLVE_Seq(tree->data, tree->mod, fp, tree);
+  EVOLVE_Seq(&io->rand, tree->data, tree->mod, fp, tree);
   fclose(fp);
   
   sprintf(dum, "%s%d%s", "./", io->r_seed, "_evolve_data.txt");
@@ -750,7 +751,7 @@ int EVOLVE_Main(int argc, char **argv)
 //////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////
 
-void EVOLVE_Coalescent(t_tree *tree)
+void EVOLVE_Coalescent(MTRand* rand, t_tree *tree)
 {
   t_node   *n, *new_n, **avail;
   int       n_lineages, idx_ancestor, *rand_idx, idx_edge;
@@ -786,7 +787,7 @@ void EVOLVE_Coalescent(t_tree *tree)
   T            = tree->times->nd_t[n->num];
   do
   {
-    dt = Rexp(Bico(n_lineages, 2) / Ne);
+    dt = Rexp(rand,Bico(n_lineages, 2) / Ne);
     T  = T - dt;
 
     // PhyML_Printf("\n. T: %f", T);
@@ -809,7 +810,7 @@ void EVOLVE_Coalescent(t_tree *tree)
 
       idx_ancestor++;
 
-      rand_idx = Permutate(n_lineages);
+      rand_idx = Permutate(rand,n_lineages);
 
       avail[rand_idx[0]]->v[0] = new_n;
       avail[rand_idx[1]]->v[0] = new_n;
@@ -867,7 +868,7 @@ void EVOLVE_Coalescent(t_tree *tree)
   // tree->rates->clock_r    = 0.01 / L * (2 * tree->n_otu - 2);
   tree->rates->model_id   = GAMMA;
 
-  for (int i = 0; i < 2 * tree->n_otu - 1; ++i) tree->rates->br_r[i] = Rgamma(1., 1.);
+  for (int i = 0; i < 2 * tree->n_otu - 1; ++i) tree->rates->br_r[i] = Rgamma(rand, 1., 1.);
 
   RATES_Update_Edge_Lengths(tree);
 
@@ -877,7 +878,7 @@ void EVOLVE_Coalescent(t_tree *tree)
 //////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////
 
-void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
+void EVOLVE_Seq(MTRand* rand, calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
 {
   int     root_state, root_rate_class;
   int     site, n_otu, ns;
@@ -918,7 +919,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
   if (tree->mod->whichmodel == GTR)
   {
     for (int i = 0; i < mod->ns; ++i)
-      tree->mod->e_frq->pi_unscaled->v[i] = Uni();
+      tree->mod->e_frq->pi_unscaled->v[i] = Uni(rand);
 
     sum = 0.0;
     for (int i = 0; i < mod->ns; ++i)
@@ -927,12 +928,12 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
     for (int i = 0; i < mod->ns; ++i)
       tree->mod->e_frq->pi->v[i] = tree->mod->e_frq->pi_unscaled->v[i] / sum;
 
-    tree->mod->r_mat->rr_val->v[AC] = log(Uni() * (2. - .5) + .5);
-    tree->mod->r_mat->rr_val->v[AG] = log(Uni() * (8. - 2.) + 2.);
-    tree->mod->r_mat->rr_val->v[AT] = log(Uni() * (2. - .5) + .5);
-    tree->mod->r_mat->rr_val->v[CG] = log(Uni() * (2. - .5) + .5);
-    tree->mod->r_mat->rr_val->v[CT] = log(Uni() * (8. - 2.) + 2.);
-    tree->mod->r_mat->rr_val->v[GT] = log(Uni() * (2. - .5) + .5);
+    tree->mod->r_mat->rr_val->v[AC] = log(Uni(rand) * (2. - .5) + .5);
+    tree->mod->r_mat->rr_val->v[AG] = log(Uni(rand) * (8. - 2.) + 2.);
+    tree->mod->r_mat->rr_val->v[AT] = log(Uni(rand) * (2. - .5) + .5);
+    tree->mod->r_mat->rr_val->v[CG] = log(Uni(rand) * (2. - .5) + .5);
+    tree->mod->r_mat->rr_val->v[CT] = log(Uni(rand) * (8. - 2.) + 2.);
+    tree->mod->r_mat->rr_val->v[GT] = log(Uni(rand) * (2. - .5) + .5);
 
     tree->mod->r_mat->n_diff_rr = 6;
     tree->mod->whichmodel       = GTR;
@@ -942,7 +943,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
   else if (tree->mod->whichmodel == HKY85)
   {
     for (int i = 0; i < mod->ns; ++i)
-      tree->mod->e_frq->pi_unscaled->v[i] = Uni();
+      tree->mod->e_frq->pi_unscaled->v[i] = Uni(rand);
 
     sum = 0.0;
     for (int i = 0; i < mod->ns; ++i)
@@ -951,7 +952,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
     for (int i = 0; i < mod->ns; ++i)
       tree->mod->e_frq->pi->v[i] = tree->mod->e_frq->pi_unscaled->v[i] / sum;
 
-    tree->mod->kappa->v = Uni() * (8. - 2.) + 2.;
+    tree->mod->kappa->v = Uni(rand) * (8. - 2.) + 2.;
 
     tree->mod->custom_mod_string->s[0] = '0';
     tree->mod->custom_mod_string->s[1] = '1';
@@ -986,7 +987,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
       tree->mod->e_frq->pi->v[i] = tree->mod->e_frq->pi_unscaled->v[i] / sum;
 
 
-    tree->mod->kappa->v = Uni() * (8. - 2.) + 2.;
+    tree->mod->kappa->v = Uni(rand) * (8. - 2.) + 2.;
 
     tree->mod->custom_mod_string->s[0] = '0';
     tree->mod->custom_mod_string->s[1] = '1';
@@ -1144,7 +1145,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
     for (int i = 0; i < n_classes; ++i) xi[i] *= (sumu/sumux);
     for (int i = 0; i < n_classes; ++i) ui[i] *= (1.0/sumu);
 
-    r_mult = xi[Sample_i_With_Proba_pi(ui,n_classes)];
+    r_mult = xi[Sample_i_With_Proba_pi(rand,ui,n_classes)];
 
     Free(xi);
     Free(ui);
@@ -1160,7 +1161,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
       Update_PMat_At_Given_Edge(tree->a_edges[i], tree);
 
     // Pick the root nucleotide/aa
-    root_state = EVOLVE_Pick_State(mod->ns, mod->e_frq->pi->v);
+    root_state = EVOLVE_Pick_State(rand,mod->ns, mod->e_frq->pi->v);
     tree->a_nodes[0]->c_seq->state[site] =
         Reciproc_Assign_State(root_state, tree->io->datatype);
     tree->a_nodes[0]->c_seq->d_state[site] = root_state;
@@ -1176,7 +1177,8 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
     /* Generic_Exit(__FILE__,__LINE__,__FUNCTION__); */
 
     /* tree->a_nodes[0] is considered as the root t_node */
-    EVOLVE_Seq_Recur(tree->a_nodes[0], tree->a_nodes[0]->v[0],
+    EVOLVE_Seq_Recur(rand,
+                     tree->a_nodes[0], tree->a_nodes[0]->v[0],
                      tree->a_nodes[0]->b[0], root_state, root_rate_class, site,
                      data, mod, tree);
 
@@ -1218,7 +1220,7 @@ void EVOLVE_Seq(calign *data, t_mod *mod, FILE *fp_stats, t_tree *tree)
 //////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////
 
-int EVOLVE_Pick_State(int n, phydbl *prob)
+int EVOLVE_Pick_State(MTRand* rand, int n, phydbl *prob)
 {
   // int    pos;
   // phydbl uni;
@@ -1233,13 +1235,14 @@ int EVOLVE_Pick_State(int n, phydbl *prob)
   // } while (1);
 
   // return (int)pos;
-  return((int)Sample_i_With_Proba_pi(prob, n));
+  return((int)Sample_i_With_Proba_pi(rand, prob, n));
 }
 
 //////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////
 
-void EVOLVE_Seq_Recur(t_node *a, t_node *d, t_edge *b, int a_state, int r_class,
+void EVOLVE_Seq_Recur(MTRand* rand,
+                      t_node *a, t_node *d, t_edge *b, int a_state, int r_class,
                       int site_num, calign *gen_data, t_mod *mod, t_tree *tree)
 {
   int d_state;
@@ -1257,7 +1260,7 @@ void EVOLVE_Seq_Recur(t_node *a, t_node *d, t_edge *b, int a_state, int r_class,
     //              b->Pij_rr[r_class * dim1 + a_state * dim2 + 3]);
 
   d_state =
-      EVOLVE_Pick_State(mod->ns, b->Pij_rr + r_class * dim1 + a_state * dim2);
+      EVOLVE_Pick_State(rand,mod->ns, b->Pij_rr + r_class * dim1 + a_state * dim2);
 
   //   PhyML_Printf("\n>> %c->%c L:%G %G %G %G %G",
   //                Reciproc_Assign_State(a_state, mod->io->datatype),
@@ -1281,7 +1284,8 @@ void EVOLVE_Seq_Recur(t_node *a, t_node *d, t_edge *b, int a_state, int r_class,
     for (i = 0; i < 3; i++)
       if (d->v[i] != a && !(a == tree->n_root && d->b[i] == tree->e_root))
       {
-        EVOLVE_Seq_Recur(d, d->v[i], d->b[i], d_state, r_class, site_num,
+        EVOLVE_Seq_Recur(rand,
+                         d, d->v[i], d->b[i], d_state, r_class, site_num,
                          gen_data, mod, tree);
       }
   }
