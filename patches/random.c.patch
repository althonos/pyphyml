diff --git a/src/random.c b/src/random.c
new file mode 100644
index 0000000..e5cb4c1
--- /dev/null
+++ b/src/random.c
@@ -0,0 +1,88 @@
+/*
+
+PhyML:  a program that  computes maximum likelihood phylogenies from
+DNA or AA homologous sequences.
+
+Copyright (C) Martin Larralde. Dec 2025.
+Copyright (C) Stephane Guindon. Oct 2003 onward.
+
+All parts of the source except where indicated are distributed under
+the GNU public licence. See http://www.opensource.org for details.
+
+*/
+
+#include <stdint.h>
+#include <stdio.h>
+
+#include "random.h"
+
+/* An implementation of the MT19937 Algorithm for the Mersenne Twister
+ * by Evan Sultanik.  Based upon the pseudocode in: M. Matsumoto and
+ * T. Nishimura, "Mersenne Twister: A 623-dimensionally
+ * equidistributed uniform pseudorandom number generator," ACM
+ * Transactions on Modeling and Computer Simulation Vol. 8, No. 1,
+ * January pp.3-30 1998.
+ *
+ * http://www.sultanik.com/Mersenne_twister
+ */
+
+#define UPPER_MASK		0x80000000
+#define LOWER_MASK		0x7fffffff
+#define TEMPERING_MASK_B	0x9d2c5680
+#define TEMPERING_MASK_C	0xefc60000
+
+/**
+* Initialize a random number generator from a given seed.
+*/
+void MTRand_Seed(MTRand* rand, uint32_t seed) {
+  /* set initial seeds to mt[MT_STATE_VECTOR_LENGTH] using the generator
+   * from Line 25 of Table 1 in: Donald Knuth, "The Art of Computer
+   * Programming," Vol. 2 (2nd Ed.) pp.102.
+   */
+  rand->mt[0] = seed & MT_RAND_MAX;
+  for(rand->index=1; rand->index<MT_STATE_VECTOR_LENGTH; rand->index++) {
+    rand->mt[rand->index] = (6069 * rand->mt[rand->index-1]) & MT_RAND_MAX;
+  }
+}
+
+/**
+ * Generates a pseudo-randomly generated long.
+ */
+uint32_t MTRand_Long(MTRand* rand) {
+
+  uint32_t y;
+  static uint32_t mag[2] = {0x0, 0x9908b0df}; /* mag[x] = x * 0x9908b0df for x = 0,1 */
+  if(rand->index >= MT_STATE_VECTOR_LENGTH || rand->index < 0) {
+    /* generate MT_STATE_VECTOR_LENGTH words at a time */
+    int32_t kk;
+    if(rand->index >= MT_STATE_VECTOR_LENGTH+1 || rand->index < 0) {
+      MTRand_Seed(rand, 4357);
+    }
+    for(kk=0; kk<MT_STATE_VECTOR_LENGTH-MT_STATE_VECTOR_M; kk++) {
+      y = (rand->mt[kk] & UPPER_MASK) | (rand->mt[kk+1] & LOWER_MASK);
+      rand->mt[kk] = rand->mt[kk+MT_STATE_VECTOR_M] ^ (y >> 1) ^ mag[y & 0x1];
+    }
+    for(; kk<MT_STATE_VECTOR_LENGTH-1; kk++) {
+      y = (rand->mt[kk] & UPPER_MASK) | (rand->mt[kk+1] & LOWER_MASK);
+      rand->mt[kk] = rand->mt[kk+(MT_STATE_VECTOR_M-MT_STATE_VECTOR_LENGTH)] ^ (y >> 1) ^ mag[y & 0x1];
+    }
+    y = (rand->mt[MT_STATE_VECTOR_LENGTH-1] & UPPER_MASK) | (rand->mt[0] & LOWER_MASK);
+    rand->mt[MT_STATE_VECTOR_LENGTH-1] = rand->mt[MT_STATE_VECTOR_M-1] ^ (y >> 1) ^ mag[y & 0x1];
+    rand->index = 0;
+  }
+  y = rand->mt[rand->index++];
+  y ^= (y >> 11);
+  y ^= (y << 7) & TEMPERING_MASK_B;
+  y ^= (y << 15) & TEMPERING_MASK_C;
+  y ^= (y >> 18);
+  return y;
+}
+
+/**
+ * Generates a pseudo-randomly generated double in the range [0..1].
+ */
+double MTRand_Double(MTRand* rand) {
+  double r = (double)MTRand_Long(rand);
+  r /= MT_RAND_MAX;
+  return r;
+}
\ No newline at end of file
